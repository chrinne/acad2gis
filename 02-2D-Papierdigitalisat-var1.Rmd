--- 
title: "CAD-Dokumentation zu GIS mit SpatiaLite migrieren"
author: "Christoph Rinne"
date: "`r format(Sys.time(), '%d. %B %Y')`"
always_allow_html: true
output:
  pdf_document:
    fig_caption: true
    number_sections: true
    toc: true
    toc_depth: 4
    df_print: kable
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: true
license: CC-BY-SA 4.0
header-includes: \renewcommand{\contentsname}{Inhalt} \renewcommand{\figurename}{Abb.}
  \renewcommand{\tablename}{Tab.}
bibliography: ./inst/references.bib
csl: ./inst/journal-of-archaeological-science.csl
papersize: a4
email: crinne@ufg.uni-kiel.de
urlcolor: blue
link-citations: yes
linkcolor: blue
number_sections: yes
lang: de-DE
description: Handreichung zur Nachnutzung von CAD-Digitalisaten einer auf Papier dokumentierten Ausgrabung.
---

\newpage

# Vorwort {-}

Ziel ist die Überführung von Ausgrabungsplänen aus CAD-Dateien in ein GIS. Ausgang ist die  Retrodigitalisierung (2D) einer Papierdokumentation einer über vier Jahre erfolgten Ausgrabung des Kollektivgrabes Odagsen 1, Stadt Einbeck, Ldkr. Northeim. Hierbei geht es nicht um einen schönen, interaktiven Plan in einem GIS am Ende, sondern um die Nachnutzung möglichst vieler Daten für eine räumliche Statistik.

**Anmerkungen** 

 - Menüpfade oder Abfolgen von Fenstern werden mit schlichten Pfeilen dargestellt: "Datei > Speichern". 
 - Tastaturkürzel, die ich gerne Nutze, stehen in Spitzklammern je Taste: \<strg> + \<c>. 
 - Schalter auf Formularen werden in [] gesetzt: [OK] 
 - Zur Darstellung von Befehlen im Text nutze ich die in Markdown übliche Darstellung von Code oder eben Anweisungen an den Computer: ```anweisung```. 
 - Der Text enthält viele Links die auf Papier nicht funktionieren. Sparen Sie bitte Papier und verzichten Sie auf den Ausdruck. 

```{r knitr global options, include=FALSE}
# Global options for knitr
knitr::opts_chunk$set(echo = TRUE, fig.align = "center")
```

```{r Install required packages and load, include=FALSE}
# Install required packages
require(pacman) || install.packages("pacman")
pacman::p_load(DT, knitr)
```

```{r R-script-load-library-setup-connection, include=FALSE}
library(RSQLite)
od1db<-dbConnect(RSQLite::SQLite(), dbname = "./data/Odagsen1.sqlite")
```

```{sql 'basic drop table', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
DROP TABLE  IF EXISTS "block_line_2d";
DROP TABLE IF EXISTS "insline_layer_2d";
DROP VIEW IF EXISTS "insline_layer_2d_view";
DROP TABLE IF EXISTS "line_layer_2d";
DROP TABLE IF EXISTS "polyg_layer_2d";
DROP TABLE IF EXISTS "text_layer_2d";
```

# Einführung

## Verwendete Software & Informationen

 - OS Windows 10
 - QGIS 3.22.4-Białowieża Quelle: [https://qgis.org]
 - SpatiaLite SpatiaLite GUI 2.1.0 beta1, SpatiaLite 5.0.0, SQLite 3.33.0, Quelle [http://www.gaia-gis.it]
 - AutoCAD 2010, Quelle für aktuelle *kostenlose* Schulversionen:  [https://www.autodesk.de/education/edu-software/overview]
 
 - SpatiaLite Cookbook html [http://www.gaia-gis.it/gaia-sins/spatialite-cookbook/index.html]
 - SpatiaLite Funktionen [http://www.gaia-gis.it/gaia-sins/spatialite-sql-5.0.0.html] 

AutoCAD ist eine sehr komplexe Software und Ausgrabungen können eine komplexe Struktur annehem, die es zu dokumentieren gilt. Erwarten Sie nicht, dass die notwendige Kompetenz beim Erstellen der digitalen Daten stets vorhanden war, auch der Autor (Chr. Rinne) ist hier nur Autodidakt. 

Rechnen Sie mit Fehlern im originalen Datenbestand und einer ggf. nicht optimalen Struktur oder erwarten Sie nicht die von Ihnen bevorzugte Struktur. Korrektur von Fehler und Anpassungen der Struktur erfolgen sicher am besten im originalen Arbeitsumfeld, also CAD.

Neben AutoCAD gibt es teils kostengünstigere Alternativen, u.a.:

 - BricsCAD [https://www.bricsys.com]
 - MegaCAD [https://www.megacad.de/]

## Originaldaten

### Ausgrabung

Die Daten stammen von der Ausgrabung und Auswertung des spätneolithischen Kollektivgrabes [Ogasen I](https://www.jna.uni-kiel.de/index.php/jna/issue/view/23), Stadt Einbeck, Ldkr. Northeim in Niedersachsen. Die Ausgrabung erfolgte in vier Kampagnen von 1981 bis 1984 als Forschungs- und Lehrgrabung des Institutes für Ur- und Frühgeschichte der Georg-August-Universität in Niedersachsen (@rinneOdagsenUndGrossenrode2003a; @heegeHauserTotenJungsteinzeitliche1989). In diesen Kampagnen  wurden zahlreiche Schnitte und eine wechselnde Anzahl von Plana angelegt als auch die dazwischen ursprünglich belassenen Profilstege sukzsessive abgebaut und auf insgesamt 154, meist einzelnen und neu gerichteten Din A3-Blättern im M 1:20 dokumentiert. Zu den jeweiligen Planblättern wurden Überlieger auf Transparentpapier mit Nivellierwerte und weiteren Angaben angefertigt. Die Einmessung erfolgte mit Theodolit, Nivelliergerät und Maßband.

### Digitalisierung in AutoCAD

Die die Digitalisierung der Planzeichnungen erfolgte im Mai und Juni 1997 in AutoCAD Ver. 12 (DOS) und Ver. 13 (Windows 3.1) auf einem Din-A3-Grafiktablett und mit Referenzierung anhand der Koordinatenangaben auf den Blättern. Jede Datei erhielt eine stringent vergeben Namen ODS(chnitt)<SchnittNr> P(lanum)<Planumnummer des Blattes> <fortlaufender Zähler>, z.B. ODS1P102. Für jedes Blatt wurde die Planumsangabe der Zeichnung,  die Planumsangabe mit Bezug auf die Angabe der Ausgräberin, die Bearbeitungszeit, die mittlere Angabe der Nivellierwerte  zum Fixpunkt der Oberfläche erfasst. Ergänzt wurden nachträglich die gängigen Metadaten der resultierenden Dateien.

```{r 'Table 1 List of drawings and DWG files.', echo=FALSE}
tab01<-read.table("./data-raw/od_files.txt", header = TRUE, sep = "\t", dec = ",")
colnames(tab01)<-tolower(colnames(tab01))
# if output is html table as interactive datatable else table with limit
if (knitr::is_html_output()) {
  DT::datatable(tab01, filter = "top", options=list(pagelength=10), caption="Liste der
 Planzeichnungen und erstellten DWG-Dateien.")
} else {
  knitr::kable(tab01[1:9,])
}
```

Die Dateien sind einfach strukturiert. Folgende Layer wurden für Informationseinheiten verwendet: BEFUND, BEFUND_UNSICHER, BEFUNDSCHRAFF, FEUER, GRABUNGSGRENZE, GRENZE, KNOCHEN, KNOCHENSCHRAFF, STEINE, STEINESCHRAFF, TPROFIL. Alle Linien wurden als 2D-Polygone digitalisiert, allerdings wurden die Polygone nicht geschlossen, sondern bei der oft dichten Lage von Steinen und Knochen nur sauber an den gemeinsamen Punkten gefangen. 

Als Störungen klassifizierte Befunde haben eine horizontale Linienschraffur, Sandsteine erhielten eine Punktschraffur und gebrannte Steine eine diagonale Schraffur auf dem Layer "FEUER", um diese Information zu vermitteln. Knochen wurden ausschließlich für den optischen Effekt stets schraffiert. Die Schraffuren wurden nicht je Objekt, sondern meist für zahlreiche Objekte angelegt, wodurch diese Schraffuren als ein Objekt über mehrere Steine oder Knochen laufen und der Mittelpunkt dieser Schraffur räumlich nicht mit einem Objekt zusammenhängt. Dies trifft vor allem auf Knochen zu, bei den eher singulären Sandsteinen oder im Verbund gebrannten Steinen ist ein räumlicher Kontext eher gegeben.

Symbole für Holzkohle, Rotlehm und verbrannte Knochen wurden als grafische Blöcke mit den Namen HK, RL, LB eingefügt. Diese können mit dem jeweiligen Datei-, Layer- und Blocknamen als auch den Koordinaten aus allen Zeichnungen eines Ordners in eine Tabelle exportiert werden (s.u. Vorbereitung in AutoCAD).

## Vorbereitung in AutoCAD

### Export in DXF

Für den Export aller DWG-Datei in DXF kann ein Script geschrieben und als Startoption an AutoCAD innerhalb eines Batch-Scriptes übergeben werden. Die Batch-Datei zum Starten von AutoCAD wird im Ordner der DWG-Dateien aufgerufen, wodurch das Arbeitsvezeichnis hier liegt und die Pfadangaben im Skript (*.scr) entfallen können.

```{bash 'Starten von AutoCAD mit einem Skript.', eval=FALSE, include=TRUE}
REM Command to start ACAD with the script to convert all DWG files to DXF
"c:\Program Files\Autodesk\AutoCAD 2014\acad.exe" /b od_convert_dwg2dxf.scr
```

Das Script für AutoCAD wiederholt die Befehle für jede DWG-Datei und muss mit einer **Leerzeile enden**. Sollten Sie in der DWG Änderungen vornehmen (s.u.) und wollen diese auch speichern ergänzen Sie die den Befehl "*\_qsave*". 

```{bash 'Skript zur Konvertierung.', eval=FALSE, include=TRUE}
;; Script file for AutoCAD
;; Start AutoCAD on the command line with option: /b script-file.scr"
_open
ODS1P101.DWG
_saveas
dxf
16
ODS1P101.DXF
_close
_open
ODS1P102.DWG
...
<blank line>
```

### Einheiten

AutoCAD kennt Enheiten (inch, mm, m etc) und rechnet diese automatisch ineinander um. Dies wird leider oft ignoriert, so dass DWG-Dateien in der Archäologie zwar in Metern gemessen sind, die Angabe zur Einheit aber auf dem Standard "Millimeter" steht oder sogar eventuell auf Inch (Britisch). Dies kann im Export-Script gleich mit angepasst werden, um die automatische Skalierung um den Faktor 1000 bei einem heterogenem Datenbestand zu vermeiden. Dazu im vorangehenden Code nach dem Öffnen der DWG-Datei und vor dem Speichern (*\_saveas*) den folgenden Code einfügen. Hierbei steht die 6 für "Meter", 5 für "Zentimeter" und 4 für "Millimeter".

```{bash 'Skript-Befehl für Einheit "Meter".', eval=FALSE, include=TRUE}
INSUNITS
6
```

Sollten die Zeichnungen darüber hinaus tatsächlich falsch skaliert sein, kann dies in einem Zug mit folgender Befehlsfolge im Script erledigt werden. Die Leerzeile nach "all" beendet die Objektwahl und ".01" ist durch den notwendigen Faktor zu ersetzen. Für die Optik können Sie noch ein "Zoom" "G" (Grenzen) ergänzen.

```{bash 'Skript-Befehl für die Skalierung.', eval=FALSE, include=TRUE}
_scale
all

0,0,0
.01
```

### Schraffuren zerlegen

Schraffuren kodieren oft Informationen, sind aber schlecht in ein GIS zu überführen. Werden Schraffuren in die zugehörigen Elemente, z.B. einzelne Linien zerlegt, handelt es sich um den Import einer schlichten Geometrie. In einem GIS kann dann mit eine räumliche Verbindung (*spatial join*) zwischen den unterschiedlichen Objekten hergestellt werden. Im vorliegenden Fall könnten dann alle Steine mit mindestens einem Linienmittelpunkt vom Layer "FEUER"  als gebrannt markiert werden. Dazu muss vor dem Speichern (*\_saveas*) folgender Code eingefügt werden. 

```{bash 'Skript-Befehl für das Auflösen von Schraffuren.', eval=FALSE, include=TRUE}
(setq SS (ssget "x" '((0 . "hatch") (8 . "FEUER"))))
(if SS
 (progn
  (setq CNT 0)
  (repeat (sslength SS)
   (vl-cmdf "._explode" (ssname SS CNT))
   (setq CNT (1+ CNT))
  )
 )
)
<blank line>
```

Da dies nicht ganz selbsterklärend ist, eine knappe Erläuterung: Die erste Zeile definiert die Variable "ss" und weist dieser mit ssget aus der gesamten Datei "x" die Objekte zu, die der folgende Liste an Parametern entsprechen (*dotted pairs*, d.h. Attributkennziffer . Wert). Wenn die Variable "ss" Inhalt hat wird eine Abfolge (*progn*) von Anweisungen durchgeführt: 1. ein Zähler mit dem Startwert "0" definiert und dann auf alle Elemente der Auswahl "ss" der Befehl "*explode*" ausgeführt, wobei der jeweilige Objektname anhand des Zählers ermittelt wird. 

### Datenextraktion

In AutoCAD können aus einzelnen oder auch vielen Zeichnungen eines Ordners diverse Elemente mit deren Attributen als Liste exportiert werden (*\_dataextraction*). Die Befehlsführung ist weitgehend intuitiv. In den einzelnen Fenstern kann die Auswahl an Elemente und Attribute durch entsprechende Anzeigeoptionen bzw. Filter gesteuert werden. Im Beispiel Odagsen "Nur Blöcke Anzeigen" für die Auswahl von "HK", "LB" und "RL". Dann den Kategorienfilter auf "Allgemein", "Geometrie" und "Zeichnung" setzen um dan nur die Attribute "Dateiname", "Layer", "Position x","Position Y" und "Position Z" zu wählen. **Wichtig**: der Export muss wegen der Punkt-Komma-Problematik als CSV-Datei gespeichert werden.

In diesem Fall erkennt der DXF-Import sowohl die Blockdefinitionen als auch die Einfügepunkte und listet diese korrekt (s.u.). Eine Datenextraktion ist deshalb nicht notwendig.

# SpatiaLite GUI

Starten Sie die SpatiaLite GUI und erstellen Sie eine neue, leere Datenbank. In diesem Fall werden die vielen DXF-Dateien nicht einzeln, sondern der gesamte Ordner importiert: "Menu > Advanced > Import DXF drawings". Wählen Sie dann nur eine DXF-Datei aus und ändern Sie im Importfenster dann die Angabe auf "(x) Import any DXF drawing file from selected folder". Da ein lokales Koordinatensystem verwendet wurde belassen Sie SRID auf "-1". Weitere Angaben: "(x) automatic 2D/3D", "(x) mixed layers (distinct by type)", "(X) none" für das *Ring handling* also das erkennen von sog. Donuts. Nach einer kurzen Wartezeit wurden folgende Tabellen und Sichten erstellt:

- block_line_2d: die Linien der grafischen Blockdefinitionen in jeder Datei.
- insline_layer_2d: Eine Liste der eingefügten Blöcke in jeder Datei, u.a. mit Datei-, Layer und Blocknamen als auch x, y und z-Koordinate des Einfügepunktes.    
- insline_layer_2d_view: Die Kombination der beiden vorgenannten Dateien in einer Sicht, die im vorliegenden Fall zwar offensichtlich korrekte Geometrien enthält, in QGIS im Kartenfenster aber dennoch nicht dargestellt wird.
- line_layer_2d: sehr viele Linien  der diversen Objekte (Steine, Knochen etc.) mit jeweiligem Datei- und Layernamen.
- polyg_layer_2d: Deutlich weniger Polygone mit jeweiligem Datei- und Layernamen.
- text_layer_2d: Die Texte in den DXF-Dateien, z.B. Befund und Profilnummern, mit dem zugehörigen Einfügepunkt, Datei- und Layernamen. 

## Datenkontrolle

Es folgt eine Datenkontrolle mit Überarbeitung, die vor allem die Geometrien betrifft. Hier sind teils durch das unsaubere Digitalisieren doppelte Knoten vorhanden oder einige Polygone überschneiden sich selbst. 

### line_layer_2d

Zahlreiche **fehlerhafte Geometrien** können über das Kontextmenü repariert werden:
Spalte "geometry" Kontextmenü > "Malfomed geometries". Liefert 501 fehlerhafte Geometrien: 1. überwiegend wiederholter Knoten (*repeated vertex*), 2. fehlerhafte Geometrie durch zu wenig Punkte. Bestätigen Sie [Repair], um das erste Problem direkt zu lösen. Sollten Sie die Daten prüfen und von Hand korrigieren wollen, dann führen Sie folgende Befehle nacheinander aus.

```{sql 'Überprüfen und korrigieren der Geometrien.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
-- Eine Geometrie mit Fehler zur Kontrolle ansehen
Select astext("geometry") from "line_layer_2d" 
 where "feature_id" = 32;
-- Die Korrektur ansehen
Select astext(sanitizegeometry("geometry")) from "line_layer_2d" 
 where "feature_id" = 32;
-- Die Korrektur ausführen
Update "line_layer_2d"
 set geometry = sanitizegeometry("geometry")
 where isvalid("geometry") = 0;
```

Es bleiben 78 fehlerhafte Geometrien mit "Repeated vertex. Too few points in geometry ...".  Die Kontrolle der Geometrie von Feature 412 zeigt drei identische Punkte. Verallgemeinernd können wir mit folgender Abfrage diese fehlerhaften erst finden und dann auch löschen:

```{sql 'Fehlerhafte Geometrien: Doppelter Punkt.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
-- Fehlerhafte Linien aus idetischen Punkten finden.
select * from "line_layer_2d"
where st_length("geometry") = 0 and isvalid("geometry") <> 1;
-- Löschen dieser Linien
Delete from "line_layer_2d"
where st_length ("geometry") = 0 and isvalid("geometry") <> 1;
```

Weitere Merkmale von möglicherweise fehlerhafter Linien können gesucht und ggf. gelöscht werden.

Eine Linie besteht nur aus drei Punkten, wobei Start und Endpunkt identisch sind. 
```{sql 'Ring mit drei Punkten', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Select "feature_id", "layer", numpoints("geometry")
from "line_layer_2d"
where StartPoint("geometry") = EndPoint("geometry") and numpoints("geometry") = 3;
```

Die Linien könnten alledings als einfach Linie von Bedeutung sein, deshalb wird nur ein Punkt gelöscht. Anmerkung: die Funktion RemovePoint zählt 0-basiert.

```{sql 'Ring aus 3 Punkten korrigieren.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Update "line_layer_2d"
set "geometry" = RemovePoint("geometry",2)
where StartPoint("geometry") = EndPoint("geometry") and numpoints("geometry") = 3;
```

Je nach Kontext könnten Linien mit zwei Punkten oder besonders kurze Linien auch weniger plausibel sein. 

Abschließend ein Überblick über den Datenbestand:

```{sql 'Datenbestand in line_layer_2d', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
SELECT Count(*), "layer", GeometryType("geometry")
FROM "line_layer_2d"
GROUP BY 2, 3;
```

### poly_layer_2d

Auch hier zuerst **fehlerhafte Geometrien** über das Kontextmenü reparieren:
Spalte "geometry" Kontextmenü > "Malfomed geometries": Wiederholte Knoten (*repeated vertex*) reparieren. Ringe mit weniger als 4 Punkten entsprechen den Linien mit identischem Start- und Endpunkt. fehlerhafte Geometrie durch zu wenig Punkte. Bestätigen Sie [Repair], um das erste Problem direkt zu lösen. Die zugehörige Funktion ist "ST_MakeValid(geom)". Sollten Sie die weiteren fehlerhaften Daten prüfen und von Hand korrigieren wollen, dann führen Sie folgende Befehle nacheinander aus.

```{sql 'Ringe mit weniger als vier Knoten.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
select "feature_id", "layer", astext("geometry") 
from "polyg_layer_2d"
where isvalid("geometry") = 0 and st_npoints("geometry") < 4;
-- Löschen mit 
Delete from "polyg_layer_2d"
where isvalid("geometry") = 0 and st_npoints("geometry") < 4;
```

Es bleiben noch die sich überschneidenden Polygone, zur visuellen Kontrolle 

```{sql 'empty sql code chunk', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
select "feature_id", "layer", st_npoints("geometry"), astext("geometry") 
from "polyg_layer_2d"
where isvalid("geometry") <> 1;
```

Die Polygone können mit der Funktion "ST_RingsCutAtNodes(geom)" in ein Multilinenobjekt zerteilt werden. Etwas einfacher und eventuell auch erfolgreich ist die Anwendung der Funktion "MakeValid("geometry")" die ein Multipolygon zurückgibt. Um keine gemischten Geometrien zu erhalten, was durch die Prüfroutinen (*trigger*) auch verhindert wird, sollte die Geometrie von polyg_layer_2d vorher angepasst und zu einem Multipolygon verändert werden.

Anmerkung: Durch das Entfernen  der Geometrieinformationen erscheinen die Index-Tabellen aus dem Bereich "Spatial Index" nach einem *refresh* jetzt unter den "User Data". Mit Wiederherstellung des Index werden diese alten Indices gelöscht.

```{sql 'Multipolygone erstellen und fehlerhafte reparieren.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
-- Prüfroutinen entfernen, die Parameter sind hier Text.
select DiscardGeometryColumn('polyg_layer_2d', 'geometry');
-- Nur die Konvertierung zu Multipolygon und Reparatur ausführen.
update "polyg_layer_2d"
set "geometry" = CastToMulti(MakeValid("geometry"));
-- Prüfroutine wieder einrichten, Parameter als Text.
select RecoverGeometryColumn('polyg_layer_2d', 'geometry', -1, 'MULTIPOLYGON','XY');
-- Rückgabewert 1 wenn ok.
-- Und den Index der Geometrie neu generieren.
Select CreateSpatialIndex('polyg_layer_2d', 'geometry');
-- Rückgabewert 1 wenn ok, dennoch zur Kontrolle.
SELECT Count(*), GeometryType("geometry"), Srid("geometry"), CoordDimension("geometry")
FROM "polyg_layer_2d"
GROUP BY 2, 3, 4
```

Zur Kontrolle und falls nur einfache Polygone gewünscht sein sollten:

```{sql 'Multipolygone mit mehr als einem Polygon listen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
SELECT *, st_numgeometries("geometry")
FROM "polyg_layer_2d"
where st_numgeometries("geometry") > 1;
```

Die Fälle mit genau zwei Subpolygonen können getrennt werden.  

```{sql 'Multipolygone trennen', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
with recursive cnt(x) as 
 (select 1
 union all
 select x+1 from cnt limit 2)
select "filename", "layer", AsText(CastToMulti(ST_GeometryN("geometry", x))) as "geometry"
 from cnt,  "polyg_layer_2d" as "b"
  where ST_NumGeometries("b"."geometry") = 2; 
```

Um diese Multipolygone mit genau zwei Subpolygonen getrennt anzufügen muss eine "*insert into*"-Anweisung eingefügt werden. Danach noch die ursprünglichen Polygone löschen und die Tabellen der Datenbank aktualisieren.

```{sql 'Multipolygone trennen und anfügen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
with recursive cnt(x) as 
 (select 1
 union all
 select x+1 from cnt limit 2)
insert into  "polyg_layer_2d" ("filename", "layer", geometry)
select "filename", "layer", CastToMulti(ST_GeometryN(geometry, x)) as geometry 
 from cnt,  "polyg_layer_2d" as b
  where ST_NumGeometries(b.geometry) = 2;
```

```{sql 'Originale Multipolygone löschen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Delete from polyg_layer_2d
 where ST_NumGeometries("geometry") = 2;
```

```{sql 'Tabellen der Datenbank aktualisieren.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Select UpdateLayerStatistics();
```
  
Zum Abschluss der Prüfung eine Übersicht zum Datenbestand:

```{sql 'Datenbestand in polyg_layer_2d', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
SELECT Count(*), "layer", GeometryType("geometry")
FROM "polyg_layer_2d"
GROUP BY 2, 3;
```

## Linien zu Polygone

Sehr viele Steine und Knochen wurden nicht als Polygone erkannt. Im Folgenden werden möglichst viele Linien, die eigentlich Polygone darstellen sollten in diese konvertiert und in die Tabelle der Polygone verschoben (kopieren & löschen). Bei diesem Pauschalen vorgehen können natürlich Ungenauigkeiten und Fehler entstehen, u.a. erneut sich selbst schneidende Polygone. Je nach Aufwand ist also eine Einzelfallprüfung vorzuziehen. 

### Pauschale Methode

Die Funktion ST_Polygonize aggregiert die Geometrien und versucht dann aus den Linien Polygone zu bilden. Durch das Aggregieren je Datei und Layer werden nachfolgend stets nur die jeweils möglichen räumlichen Bezüge der Linien berücksichtigt. Ergänzend wird eine Liste der jeweils eingehenden "*feature_id*" erstellt (*group_concat()*), um die Zugehörigen Linien identifizieren und löschen zu können. Je Datei und Layer wird ein Multipolygon erstellt.

```{sql 'Linien aggregieren und Polygone in eine temporäre Datei schreiben.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
create table tmp_polygonize as
select "filename", "layer", group_concat(feature_id) as fids,
 CastToMulti(st_Polygonize("geometry")) as geometry
from line_layer_2d
where layer in ('KNOCHEN', 'STEINE')  
group by 1, 2;
```

```{sql 'Geometrie von tmp_polygonize prüfen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
SELECT Count(*), GeometryType("geometry"), Srid("geometry"), CoordDimension("geometry")
FROM "tmp_polygonize"
GROUP BY 2, 3, 4
```

```{sql 'Wenn nötig fehlerhafte Geometrien in tmp_polygonize löschen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Delete from "tmp_polygonize"
where geometry is null
```

```{sql 'Geometriespalte von tmp_polygonize registrieren.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Select RecoverGeometryColumn('tmp_polygonize', 'geometry', -1, 'MULTIPOLYGON', 'XY')

```{sql 'Index von tmp_polygonize erstellen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Select CreateSpatialIndex('tmp_polygonize', 'geometry');
```

Im nächsten Schritt werden die zahlreichen Steine bzw. Knochen die je Datei als Multipolygon vorliegen getrennt. Die rekursive Anweisung unterscheidet sich deutlich von der vorangehenden Version für genau zwei Polygone in einem Multipolygon.

```{sql 'Tabelle individuelle Polygone per Rekursion erstellen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
create table tmp_polygonize_single as
-- Beginn der Rekursion mit zwei Zählern und Geometrie
with recursive liste ( fid, n, single ) as (
 -- Erster Datensatz
 select 1 as fid, 0 as n, NULL as single
 UNION ALL
 -- Alle folgenden Datensätze mit Entscheidung (case)
 select
 case -- Wenn die n-te Geometrie im Multipolygone existiert behalte fid sonst fid + 1
  when (select st_geometryn(geometry, n + 1) from tmp_Polygonize where rowid = fid) not null
   then fid
  else 
   fid + 1
 end as fid, -- end case und Zuweisung
 case -- dito nur n + 1 sonst 0
  when (select st_geometryn(geometry, n + 1) from tmp_Polygonize where rowid = fid) not null
   then n + 1
  else
   0
 end as n, -- end case und Zuweisung
 case -- dito nur wird jetzt die Geometrie übernommen
  when (select st_geometryn(geometry, n + 1) from tmp_Polygonize where rowid = fid) not null
   then (select st_geometryn(geometry, n + 1) from tmp_Polygonize where rowid = fid)
  else
    NULL
 end as single
from liste
 -- Limit für die Rekursion.
  where fid <= (select count(*) from tmp_polygonize))
select a.fid, a.n, CastToMulti(single) as geometry, b.filename, b.layer from liste as a 
 left join tmp_polygonize as b on a.fid = b.rowid
 where single not null;
```

Diese Rekursive Abfrage ist mit den eingefügten Bedingungen (*case*) etwas umfangreicher aber nicht wirklich kompliziert. Die Grundkonstruktion der durch Rekursion gebauten Tabelle ("liste") hat drei Spalten für zwei Zähler ("fid", "n") und eine Geometrie (single). Die Tabelle liste startet mit dem Setzen der Zähler, wobei fid = 1 und n = 0 gesetzt wird. Für alle weiteren Datenzeilen wird per *select*-Anweisung geprüft, ob im Multipolygon der gegebenen "fid" das n+1 Polygon existiert. Ist dies vorhanden wird in den drei Bedingungen: 1. die fid behalten, 2: n + 1 gesetzt und 3. das zugehörige Polygon abgefragt. Alternativ wird für das nächste Multipolygon: 1. fid + 1 und 2. n zurück auf 0 gesetzt sowie 3. keine Geometrie übergeben. Das Limit für die Rekursion wird auf die Anzahl der vorhandenen Multipolygone gesetzt. Die Abfrage der durch Rekursion erstellten Tabelle "liste" wird per *join* mit den Eingangsdaten verbunden um nachträglich Dateiname und Layer zu erhalten. Zugleich wird das einfache Polygon wieder zu einem Multipolygon für die weitere Bearbeitung umgewandelt und auf die Zeilen mit Geometrie gefiltert. Die knapp 14400 Polygone werden in weniger als 3 Sekunden verarbeitet.

Danach erfolgt das Prüfen, das Wiederherstellen und ggf. die Korrektur der Geometriespalte. 

```{sql 'Tabelle individuelle Polygone prüfen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
SELECT Count(*), GeometryType("geometry"), Srid("geometry"), CoordDimension("geometry")
FROM "tmp_polygonize_single"
GROUP BY 2, 3, 4;

Select RecoverGeometryColumn('tmp_polygonize_single', 'geometry', -1, 'MULTIPOLYGON', 'XY');

Select *, AsText(geometry) from tmp_polygonize_single
 where IsValid(geometry) <> 1;

Update tmp_polygonize_single
 set geometry = ST_MakeValid(geometry)
 where IsValid(geometry) <> 1;
```

Der dann vorliegende saubere Datenbestand kann an die Tabelle polyg_layer_2d angefügt und die Tabelle selbst gelöscht werden.

```{sql 'Tabelle der individuelle Polygone anfügen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
Insert into polyg_layer_2d (filename, layer, geometry)
 select filename, layer, geometry from tmp_polygonize_single;
-- löschen
Drop table if exists tmp_polygonize_single;
```

Wenn gewünscht noch die verarbeitetn Linien aus line_layer_2d löschen, dies erfolgt in zwei Schritten: 1. Wird eine Sicht (*view*) der verarbeiteten ID's mittels Rekursion erstellt und 2. dann mit dieser entsprechenden Einträge in der Tabelle der Linien gelöscht. Eine Ursache dafür ist das in "tmp_Polygonize" als ein langer Text und nicht als Liste von Zahlen abgelegte Ergebnis der vorangehenden *group_concat*-Anweisung.  Die Rekursion arbeitet erneut mit einer *case*-Anweisung, um jeweils das erste Element bis zum ersten "," und den Rest zu trennen. In der abschließenden Abfrage wird noch auf die Elemente ("feature_id") gruppiert, um die doppelten zu eliminieren.

```{sql 'Tabelle der zu löschenden feature_id's.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
-- Einspaltige Tabelle der feature_ids
create view tmp_delfids as
with recursive liste (element, remainder) as (
 select 0 as element, (select group_concat(fids) from tmp_Polygonize) as remainder
  union all
 select
  case
   when instr(remainder, ',') > 0 then
    substr(remainder, 0, instr(remainder, ','))
  else
   remainder
  end as element,
  case
   when instr(remainder, ',') > 0 then
    substr(remainder, instr(remainder, ',') + 1)
  else
   NULL
  end as remainder
from liste
where remainder is not null
)
select trim(element) as fid from liste where element is not null group by 1;  
```

Auf diese zuvor erstellen Sicht der ID's bezieht sich dann die folgende *delete*-Anweisung. Diese führe ich jetzt aber nicht aus, um die Einzelfallprüfung noch durchzuführen.

```{sql 'Verarbeitete Linien löschen.', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
delete from cp_line_layer_2d
where feature_id in (select fid from tmp_delfids);
```

### Polygone aus Einzelfallprüfung 

Ein Problem sind die in AutoCAD nicht geschlossen Polygone bei denen Startpunkt und Endpunkt identische Werte haben. Dies ist durch eine *insert*-Anweisung einfach zu lösen. Danach sollte der Index von polyg_layer_2d aktualisiert und die ursprünglichen Linien gelöscht werden. 

```{sql 'Linien mit identsichem Start- und Endpunkt', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
-- Anzahl der betreffenden Linien feststellen. 
SELECT Count(*), layer from line_layer_2d
where StartPoint("geometry") = EndPoint("geometry")
group by 2;
-- Diese Linien zu einem Multipolygon konvertieren mit weiteren Attributen 
-- in die Tabelle der Polygone schreiben
Insert into  "polyg_layer_2d" ("filename", "layer", geometry)
select "filename", "layer", CastToMulti(ST_BuildArea("geometry")) as geometry
from line_layer_2d where StartPoint("geometry") = EndPoint("geometry") 
 and layer in ('KNOCHEN', 'STEINE');
-- Den Index aktualisieren
Select RecoverSpatialIndex("polyg_layer_2d", "geometry");
-- Die ursprünglichen Linien löschen, bzw. zur Kontrolle feature_id archivieren
Delete from line_layer_2d 
where StartPoint("geometry") = EndPoint("geometry")
 and layer in ('KNOCHEN', 'STEINE');
```

Bei den verbleibenden Linien sind noch sehr viele auf den Layern STEINE und KNOCHEN. Um deren Struktur zu prüfen können einige Abfragen ausgeführt werden:

```{sql '', connection=od1db, eval=FALSE, message=FALSE, include=TRUE}
-- Anzahl der optionlen Linien mit mehr als 2 Knoten feststellen. 
SELECT Count(*), layer from line_layer_2d
where numpoints("geometry") > 2 
 and layer in ('KNOCHEN', 'STEINE')
group by 2;
-- Wie viele würden, direkt geschlossen, ein valides Polygon ergeben?
SELECT Count(*), layer 
from line_layer_2d
where numpoints("geometry") > 2 
 and layer in ('KNOCHEN', 'STEINE')
 and isvalid(ST_BuildArea("geometry")) = 1
group by 2;
```



inien 
Folgendes durch st_buildarea()
```
Select 'POLYGON(' || substr(astext("geometry"),11)||')'
from line_layer_2d
where "feature_id" = 28
```

```
INSERT INTO  "polyg_layer_2d" ("filename", "layer", geometry)
Select "filename", "layer", 
 ST_GeomFromText('POLYGON(' || substr(astext("geometry"),11)||')
', -1)
from line_layer_2d
where StartPoint("geometry") = EndPoint("geometry")

SELECT UpdateLayerStatistics("polyg_layer_2d", "geometry")

DELETE from line_layer_2d
where StartPoint("geometry") = EndPoint("geometry")
SELECT UpdateLayerStatistics("line_layer_2d", "geometry")
```
Kontrolle der verbleibenden Linien

```
select count("feature_id"), layer 
from line_layer_2d
group by 2
```

Befunde, Grabungsgrenze und Profile hier erstmal ignorieren, Ziel ist räumliche Statistik. Deshalb für Knochen und Steine möglichst viele Polygone schaffen:
```
select "feature_id", numpoints("geometry"), st_length("geometry")
from line_layer_2d
where layer = 'KNOCHEN'
order by 2, 3
```
Viele Linien mit nur 2 Punkten, maximal 13 cm lang und drei Punkten bis 18 cm lang. Visuelle Kontrolle der Objekte zeigt vielfach an einer kurzen Kante offene Objekte, die einfach geschlossen werden kann. Dazu oft auch langgestreckte Objekte, die nicht geschlossen werden können, da z.B. eine Überschneidung in sich erfolgen würde.

```
create table polyg_tmp as 
select "feature_id", "filename", layer,
st_GeomFromText('POLYGON(' || substr(astext("geometry"),11,length(astext("geometry"))-11)
 || ', ' || substr(astext(StartPoint("geometry")), 7) || ')', -1) as geometry
from line_layer_2d;
```

```
-- recover geometry column
-- prüfen der Geometrie
begin transaction;
SELECT Count(*), GeometryType("geometry"), Srid("geometry"), CoordDimension("geometry")
FROM "polyg_tmp"
GROUP BY 2, 3, 4;
-- indexliste für später erstellen
create temp table polyg_null_tmp as
SELECT "feature_id"
FROM polyg_tmp
where geometry is null;
-- nuller löschen
DELETE FROM polyg_tmp
where geometry is null;
-- alles löschen, was nicht knochen oder Stein ist
DELETE FROM polyg_tmp
where layer not in ('KNOCHEN', 'STEINE');
commit

create temp table poly_invalidgeom_tmp as
select "feature_id"
from polyg_tmp
where isvalid("geometry") = 0;

delete from polyg_tmp
where isvalid("geometry") = 0;
```
Sichtkontrolle zeigt weiterhin einige seltsame, sehr langschmale Objekte.



Liefert am Ende erfolgreiche und fehlerhafte Geometrien. -> visuelle Kontrolle


# Literatur
